# Часть 27

В этой главе, мы будем решать упражнение, которое мы оставили для решения в предыдущей части. Оно называется **IDA\_STRUCT.7Z**. Если Вы не решили это упражнение или у Вас его нет, загрузите его отсюда.

[http://ricardo.crver.net/WEB/INTRODUCCION AL REVERSING CON IDA PRO DESDE CERO/EJERCICIOS/IDA\_STRUCT\_RESOLVER DESPUES DE LA PARTE 26.7z](http://ricardo.crver.net/WEB/INTRODUCCION%20AL%20REVERSING%20CON%20IDA%20PRO%20DESDE%20CERO/EJERCICIOS/IDA_STRUCT_RESOLVER%20DESPUES%20DE%20LA%20PARTE%2026.7z)

Исполняемый файл называется **CONSOLEAPPLICATION4.EXE** и в том же каталоге находятся символы **CONSOLEAPPLICATION4.PDB.**

Когда **IDA** загрузит файл, то сообщит Вам, что она пытается найти символы. Вы можете указать на этот файл и загрузить символы, с которыми программу станет немного яснее понимать. Но для нашего примера, я буду удалять или переименовывать файл **PDB**, чтобы загрузить программу без символов, что соответствует тому, с чем мы обычно имеем дело. Хотя это и выглядит сложнее, зато приближено к реальности.

![](.gitbook/assets/27/01.png)

Очевидно, что без символов, функция не будет определяться как **MAIN**. Мы можем добраться до неё, так как это консольное приложение, которое ищет аргументы **ARGV** или **ARGC**, а если их нет**,** то её, обычно, можно найти через поиск строк.

Если мы запустим программу, то увидим, что первое, что она сделает - это попросит нас ввести число. Здесь Вы видите строки, которые могут быть хорошим и плохим сообщением.

![](.gitbook/assets/27/02.png)

Щелкните на строке **PLEASE ENTER YOUR NUMBER OF CHOICE:**

![](.gitbook/assets/27/03.png)

Мы видим, что строка имеет ссылки. Помещая курсор над стрелкой или нажимая клавишу **X** на адресе, мы видим, что строка имеет ссылку.

![](.gitbook/assets/27/04.png)

![](.gitbook/assets/27/05.png)

Давайте перейдём по этому адресу.

![](.gitbook/assets/27/06.png)

Видим, что мы находимся внутри функции. Далее видно вывод строки и вызов функции для печати этой строки. Поскольку у нас нет символом, **IDA** не говорит нам, что функция по адресу **0x401220** - это функция **PRINTF**. Если мы посмотрим во внутрь этой функции.

![](.gitbook/assets/27/07.png)

Вы можете посмотреть во внутрь этой функции и увидеть, что внутри есть ещё несколько функций.

![](.gitbook/assets/27/08.png)

![](.gitbook/assets/27/09.png)

В **PROXIMITY** **VIEW**, в который можно войти нажав клавишу **-** и выйти, нажав **+,** мы видим, что функция **0x401220** вызывает те же самые три функции, но две функции **0x401000** и **ACRT\_IOB\_FUNC** - это функции, которые что-то делают и возвращаются назад. Они не идут к другим дочерним функциям.

![](.gitbook/assets/27/10.png)

Здесь, где есть стрелки, которые я добавил, видно, что блоки не идут к другим функциям. Только одна функция, которая вызывает другие функции - это функция по адресу **0x4010F0**, которая вызывает две функции и первая из вызываемых, это функция **VFPRINTF.** Функция после своего выполнения возвращается обратно и ниже уже нет никаких других функций.

Это также можно увидеть в дизассемблерном списке. Если я посмотрю во внутрь каждой функции, я увижу то же самое.

Видно, что функция **0x401000** никуда не ведёт. Функция просто исполняет ерунду и возвращает выполнение.

![](.gitbook/assets/27/11.png)

![](.gitbook/assets/27/12.png)

И **\_ACRT\_IOB\_FUNC** - это **API** функция. Поэтому функция не будет продолжаться??? Функция будет только инициализировать поток **STDOUT**, чтобы затем быть готовой печатать текст.

![](.gitbook/assets/27/13.png)

Другими словам, передача аргумента **1**, как в нашем случае, будет инициализировать поток **STDOUT**.

![](.gitbook/assets/27/14.png)

И третья функция, которая будет вызываться, это функция по адресу **4010F0**.

![](.gitbook/assets/27/15.png)

Функция заканчивается вызовом **VFPRINTF**, т.е. мы пришли к тому же, что видно и в **PROXIMITY** **VIEW**, но это занимает больше времени.

![](.gitbook/assets/27/16.png)

Так что давайте переименуем функцию по адресу **0x401220** в **PRINTF**.

![](.gitbook/assets/27/17.png)

Те блоки, которые заканчиваются вызовом **API**, как в этом случае **PRINTF**, я буду закрашивать в небесный цвет. Каждый будет делать это по своему вкусу.

![](.gitbook/assets/27/18.png)

Следующая функция по адресу **0x40109D** – это конечно же функция **SCANF**. Если мы перейдём в неё и посмотрим в **PROXIMITY** **VIEW**, то увидим:

![](.gitbook/assets/27/19.png)

Здесь я нажимаю на **+,** чтобы увидеть спрятанные блоки.

![](.gitbook/assets/27/20.png)

Мы видим, что это функция **SCANF**.

![](.gitbook/assets/27/21.png)

И в этом случае, функция **\_ACRT\_IOB\_FUNC** с аргументом **0** инициализирует поток **STDIN**.

![](.gitbook/assets/27/22.png)

Поэтому, мы переименовываем эту функцию в **SCANF**.

![](.gitbook/assets/27/23.png)

![](.gitbook/assets/27/24.png)

Мы видим что-то похожее на структуру, потому что когда Вы передаёте адрес как аргумент и затем извлекаете его и прибавляете к нему смещение для доступа к полям в каждом месте, в котором они используются, возможно это является адресом структуры.

Давайте посмотрим на ссылки для следующую функции.

![](.gitbook/assets/27/25.png)

Мы видим, что есть две ссылки. Если я зайду в первую.

![](.gitbook/assets/27/26.png)

Я вижу, что аргумент в обоих случаях является адресом, который даёт представление о структурах.

Поскольку два разных адреса производят впечатление, что они были двумя структурами одного и того же типа, мы начнем создавать единую структуру, не зная размера, не зная полей или чего-то еще. Мы будем понемногу реверсить её внутреннюю структуру.

Мы видим, что максимальное смещение, которое я нахожу до настоящего времени равно **0x14.** Поэтому я буду создавать структуру этой длины. Если структура станет больше, я буду увеличивать её размер.

![](.gitbook/assets/27/27.png)

Для этого, я иду во вкладку **STRUCTURES**. Это один из способов её создания. Другой способ - это перейти в **LOCAL** **TYPES** и создать её как код в стиле **C**. Давайте так и сделаем.

Это немного раздражает и это не очень интуитивно. Но хорошо когда мы находимся в месте где определена структура. Здесь мы можем сделать **CREATE** **STRUCT** **FROM** **SELECTION**. Обычно мы будем создавать структуру в некоторой функции где она не определена, ничего не зная о ней.

Я знаю, что если проанализировать представление стека функции **MAIN**, я мог бы здесь использовать опцию **CREATE** **STRUCT** **FROM** **SELECTION** и это облегчило бы мне жизнь, но давайте возьмём наихудший случай. Представим, что мы находимся в функции очень большой программы и что мы далеко от того места, где она была определена, так что мы должны исправить их как только можем.

![](.gitbook/assets/27/28.png)

Здесь мы видим, что для создания структуры Вы должны нажать клавишу **INS.** Сделаем же это.

![](.gitbook/assets/27/29.png)

Я могу назначить имя, какое захочу. Назовём нашу структуру **MYSTRUCT**.

![](.gitbook/assets/27/30.png)

Здесь она была создана мной с размером **0**. Сейчас я буду делать трюк. Когда я всё ещё не знаю полей или чего-то ещё и я хочу дать полю размер, сначала я нажимаю **D** на слове **ENDS**, чтобы добавить одно поле.

![](.gitbook/assets/27/31.png)

Здесь я добавляю поле длиной **1** байт **DB**. Если бы я снова нажал **D**, я бы переключился на слово **DW** и затем на **DD**.

Но здесь, поскольку мы не знаем, что нам нужно, мы оставляем всё так и делаем правый щелчок на структуре.

![](.gitbook/assets/27/32.png)

Так как я видел поле со смещением **0x14**.

![](.gitbook/assets/27/33.png)

Таким образом, чтобы заполнить это поле с помощью **DWORD**, структуре нужно ещё **4** байта, поэтому я буду создавать структуру из **0x18** байт**.** Я буду добавлять ещё **0x17** байт к байту, который был у структуры.

![](.gitbook/assets/27/34.png)

![](.gitbook/assets/27/35.png)

Я вижу, что размер стал равен **0x18**. Теперь мы оставим структуру такой.

Поскольку эта функция вызывается дважды, первый раз с адресом первой структуры типа **MYSTRUCT**, которую мы будем произвольно называть **PEPE** и второй раз с адресом второй структуры того же типа **MYSTRUCT**, которую мы будем называть **JUAN.** Внутри функции, мы будем давать общее имя, которое будет обслуживать оба случая.

В исходном коде, это выглядит так. Чтобы уточнить две переменные типа **MYSTRUCT** первая называется **PEPE**, а другая **JUAN**. Обе передают свой адрес как аргумент в функцию.

![](.gitbook/assets/27/36.png)

![](.gitbook/assets/27/37.png)


Так как одна и та же функция сначала будет иметь адрес первой структуры или **PEPE** в аргументе **ARG0** и во второй раз, когда она будет вызвана она будет иметь адрес структуры **JUAN**, то я буду давать структуре общее имя для обоих случаев, например \_**STRUCT**.

Если я декомпилирую функцию с помощью **F5**, я вижу, что результат неверный.

![](.gitbook/assets/27/38.png)

Я вижу, что определение переменной является простым типом **INT**, а не как в исходном коде как адрес структуры. Я могу это исправить так.

![](.gitbook/assets/27/39.png)

Это позволяет выбрать адрес структуры, в котором она находится, и здесь мы будем выбирать тип **MYSTRUCT**.

![](.gitbook/assets/27/40.png)

Очевидно, что **BUF** - это **PEPE** и здесь он получает свой адрес и передаёт его как аргумент. Давайте посмотрим **BUF** в представлении стека.

Поэтому структура необязательна, чтобы создать её, потому что она уже существует. Я просто должен сказать Вам, что **BUF –** это переменная типа **MYSTRUCT**. Для этого нажмите сочетание **ALT** + **Q** на переменной **BUF**.

![](.gitbook/assets/27/41.png)

и **IDA** назначит переменной **BUF** тип **MYSTRUCT**. Если мы поместим размер ниже, некоторые поля будут опущены, но затем можно будет увеличить структуру **MYSTRUCT** и она будет исправлена только здесь.\(Если она не сломается конечно\)

![](.gitbook/assets/27/42.png)

Мы переименовываем **BUF** в **PEPE**.

Мы видим здесь, что адрес **PEPE** передан и во втором вызове передаётся адрес **VAR**\_**44**, которая также будет переменной **JUAN** типа **MYSTRUCT**, поэтому мы пойдём в представление стека и на переменной **VAR**\_**44** мы также нажмём **ALT** + **Q**.

![](.gitbook/assets/27/43.png)

У нас уже есть две структуры типа **MYSTRUCT**.

Я возвращаюсь в функцию.

![](.gitbook/assets/27/44.png)

![](.gitbook/assets/27/45.png)

Мы видим, что поле **0x10** является **DWORD** где оно передаётся функции **SCANF**, поэтому мы переходим в **MYSTRUCT** и в поле **0x10** мы нажимаем **D** до тех пор пока оно не будет иметь тип **DD**.

![](.gitbook/assets/27/46.png)

![](.gitbook/assets/27/47.png)

Я переименую это поле в **NUMERO**.

![](.gitbook/assets/27/48.png)

Другая запись - это поле по смещению **0x14**, которое используется в цикле для удаления символа **0xA**. Я назову его **C**.

![](.gitbook/assets/27/49.png)

Давайте пойдём в поле по смещению **0x14** структуры **MYSTRUCT** и будем нажимать **D** до тех пор пока не появится **DWORD** и давайте назовём это поле именем **C**.

![](.gitbook/assets/27/50.png)

![](.gitbook/assets/27/51.png)

Здесь мы нажимаем **T**, чтобы освежить информацию.

Наконец, я переименовываю функцию в **ENTER**.

![](.gitbook/assets/27/52.png)

Мы видим, что три первые функции вызывают **ENTER** передавая адрес **PEPE** и три следующие передают адрес **JUAN**.

Давайте посмотрим на следующую функцию.

![](.gitbook/assets/27/53.png)

Эта функция также использует обе структуры, поэтому Вы можете равно как в предыдущем случае нажать **F5**.

![](.gitbook/assets/27/54.png)

Здесь на переменной **\_STRUCT** я делаю правый щелчок и выбираю пункт **CONVERT TO STRUCT \***.

![](.gitbook/assets/27/55.png)

Сейчас, это адрес структуры **MYSTRUCT** и, как и раньше, мы увидим поля только нажав клавишу **T** в соответствующем месте.

![](.gitbook/assets/27/56.png)

Здесь мы видим, что программа сравнивает поле **NUMERO**, которое мы передали, с числом **0x10** и поскольку сравнение знаковое, любое отрицательное число может пройти. Например число **0xFFFFFFFF**, которое равно **-1** и которое меньше **0x10**.

![](.gitbook/assets/27/57.png)

Затем, программа использует **NUMERO** как размер для функции **GETS**\_**S**, которое мы передали ей и другой аргумент. Он должен быть буфером, который находится в начале структуры, потому что он использует её начальный адрес.

Я иду в **MYSTRUCT** и по смещению **0x0** нажимаю **D** один раз, чтобы создать единственное байтовое поле.

![](.gitbook/assets/27/58.png)

Теперь, здесь, я делаю правый щелчок и выбираю **ARRAY**.

![](.gitbook/assets/27/59.png)

Размер буфера будет равен **16** байт. Я соглашаюсь с этим значением.

Переименовываю это поле в **BUFFER.**

![](.gitbook/assets/27/60.png)

Размер поля теперь равен **16** десятичных байт.

Давайте продолжим реверсить.

![](.gitbook/assets/27/61.png)

Проблема состоит в том, что с помощью функции **GETS**\_**S** буфер может быть переполнен, так как функция **CHECK** позволяет передавать отрицательные значении при использовании в качестве размера. Они будут восприниматься как беззнаковые значения и будут очень большими.

Если, например, мы передадим **0xFFFFFFFF** в сравнение, значение будет равно **-1**, потому что оно идет как знаковое и будет меньше чем **0x10**, но используя его как размер, оно будет большим положительным значением **0xFFFFFFFF**, которое позволяет нам передавать количество символом, которое мы хотим через функцию **GET**\_**S** в буфер и переполнить его.

Таким образом, мы могли бы переименовать функцию в **CHECK** или **GET**. Независимо от того, что мы хотим, нужно чтобы имя отражало то, что делает функция. Мы будем проверять это соответствие.

![](.gitbook/assets/27/62.png)

У меня есть третья функция. Аргумент тот же, поэтому я повторяю процедуру, нажимаю **F5** и изменяю тип аргумента.

![](.gitbook/assets/27/63.png)

Я продолжаю реверсить.

![](.gitbook/assets/27/64.png)

Мы видим, что есть ещё одно поле, поскольку оно пытается сравнить значение \[**EAX**+**0x18**\], которое мы не определили, так как наше последнее поле структуры **MYSTRUCT** равно **0x14**. Давайте добавим его.

![](.gitbook/assets/27/65.png)

Мы помещаем указатель на слове **ENDS** и нажимаем **D** до тех пор пока не создадим новое поле **DD**.

![](.gitbook/assets/27/66.png)

Я переименовываю это поле в **COOKIE**.

![](.gitbook/assets/27/67.png)

Я возвращаюсь в нашу функцию и нажимаю **T** для обновления информации.

![](.gitbook/assets/27/68.png)

Мы видим, что существует ещё другое поле. Это единственный байт.

![](.gitbook/assets/27/69.png)

Поэтому мы возвращаемся назад в структуру **MYSTRUCT** и на слове **ENDS** нажимаем **D** один раз и у нас появляется поле из одного байта.

![](.gitbook/assets/27/70.png)

Я переименовываю это поле во **FLAG**, чтобы он совпадал с исходным кодом.

Теперь возвращаемся в функцию.

![](.gitbook/assets/27/71.png)

Если переменная **COOKIE** равна **0x99989796**, тогда программа будет устанавливать флаг структуры в **1**.

![](.gitbook/assets/27/72.png)

Если для некоторых изменений, которые не распространялись хорошо, переменные функции **MAIN** сломаются, и мы не сделали снимок, как это случилось со мной, то делаем так.

![](.gitbook/assets/27/73.png)

Я иду в начало поломанной функции и нажимаю **U**.

![](.gitbook/assets/27/74.png)

Я соглашаюсь на вопрос программы "сломать" функцию.

![](.gitbook/assets/27/75.png)

Затем, там же, в начале функции, я нажимаю **C**.

![](.gitbook/assets/27/76.png)

И затем я делаю правый щелчок и выбираю пункт **CREATE** **FUNCTION**.

![](.gitbook/assets/27/77.png)

Теперь всё хорошо.

Посмотрим в статическое представление стека.

![](.gitbook/assets/27/78.png)

Мы видим, что после каждый структуры остаются три пустых байта, потому что последнее поле было единственным байтом и больше ничего нет.

Только имена структур неправильные, но я буду менять их в соответствии с исходным коде, т. е. я изменяю имена на **PEPE** и **JUAN**.

![](.gitbook/assets/27/79.png)

![](.gitbook/assets/27/80.png)

Мы видим, что со структурой **JUAN** программа будет делать то же самое что и с **PEPE**. Структуры будут передавать свои адреса функциям **ENTER** и **CHECK**. Но программа имеет ещё третью функцию. Давайте посмотрим, что она делает.

![](.gitbook/assets/27/81.png)

Нажимая **T** в полях, мы видим, что функция похожа на функцию "**DESICION**", только константа с которой сравнивается поле **COOKIE** структуры **JUAN** отличается. В этом случае константа равна **0x33343536**.

Другими словами, поле **COOKIE** структуры **PEPE** должно быть равно значению **0x99989796** и поле структуры **JUAN** должно быть равно **0x33343536**. Только так флаги каждой структуры будут равны 1.

![](.gitbook/assets/27/82.png)

Мы видим, что для того, чтобы прийти к хорошему сообщению оба флага должны быть равны **1**.

Это упражнение имеет много решений, потому что структура **JUAN** находится выше в стеке.

![](.gitbook/assets/27/83.png)

Выполняя функции **GET\_S** мы можем перезаписать все флаги так, чтобы они остались равны **1** и таки образом, сделать это одним переполнением. Также это можно сделать индивидуально, перезаписывая в каждой функции **GET\_S** флаг и нет необходимости перезаписывать поле **COOKIE** правильным значением, потому что мы напрямую перезаписываем флаг, не дожидаясь сравнения поля **COOKIE**, чтобы изменить его.

Чтобы перезаписать флаг, у меня есть **16** десятичных байт, плюс к этому значению **3** **DWORD** или это будет **12** байт.

Общая сумма байт будет равна: **16** + **12** = **28** байт.

![](.gitbook/assets/27/84.png)

Поэтому количество фруктов будет равно: **FRUTA** = **28\*** "**A**" **+** "**\x01**"

![](.gitbook/assets/27/85.png)

Конечно, для каждой из структур Вы должны передать **-1** или отрицательное значение, которое пройдет проверку против числа **0x10**, а затем должен следовать фруктовый-шеллкод \)\).

![](.gitbook/assets/27/86.png)

Если мы немного поотлаживаем, мы увидим значение **-1**, которое помещается в поле **NUMERO** структуры **PEPE**.

![](.gitbook/assets/27/87.png)

![](.gitbook/assets/27/88.png)

Программа проходит проверку и достигает функцию **GETS\_S**. Здесь и читаются переданные фрукты.

![](.gitbook/assets/27/89.png)

Здесь я вижу адрес структуры **PEPE** на моей машине, после исполнения функции **GET\_S**. Если я пойду в стек.

![](.gitbook/assets/27/90.png)

Здесь я вижу наши **ФРУКТЫ**, которые я посылаю программе. Если я хочу сконвертировать эти данные в структуру, то я нажимаю **ALT** **+** **Q**.

![](.gitbook/assets/27/91.png)

И выбираю пункт **MYSTRUCT**.

![](.gitbook/assets/27/92.png)

Я вижу, что поля и флаг уже перезаписан на значение 1 переполнением. Не исследуя подробно другие функции, я продолжаю трассировать.

![](.gitbook/assets/27/93.png)

Мы видим, что программа сравнивает **COOKIE** со значением **0x99989796** и поскольку это разные значения, программа не изменят флаг. Но флаг уже равен **1**, поэтому это не так важно.

Тот же процесс будет повторяться и мы переходим в функцию **DECISION2**.

![](.gitbook/assets/27/94.png)

Я начинаю трассировать с помощью клавиши **F7**.

![](.gitbook/assets/27/95.png)

Регистр **EAX** имеет начало структуры **JUAN**. Давайте посмотрим на эту структуру в стеке.

![](.gitbook/assets/27/96.png)

Здесь, я также нажимаю сочетание **ALT** **+** **Q**, чтобы из байтов собрать структуру. Снова выбираем нашу структуру **MYSTRUCT**.

![](.gitbook/assets/27/97.png)

Так же как и раньше флаг будет равен **1**. Сравнение с **COOKIE** не будет равно, но программа продолжит выполняться, потому что с флагом уже всё хорошо.

![](.gitbook/assets/27/98.png)

Поле **PEPE.FLAG** равно **1** и это хорошо, поэтому продолжаем трассировку.

![](.gitbook/assets/27/99.png)

Поле **JUAN**.**FLAG** также правильное, поэтому я достигаю хорошего сообщения.

![](.gitbook/assets/27/100.png)

Готово. Теперь пример решен. Мы победили.
Увидимся в **28**-й главе.

* * *

Автор оригинального текста — Рикардо Нарваха.

Перевод и адаптация на английский  язык — IvinsonCLS.

Перевод и адаптация на русский язык — Яша Яшечкин.

Перевод специально для форума системного и низкоуровневого программирования - WASM.IN

05.01.2018

Источник:

[**http://ricardonarvaja.info/WEB/INTRODUCCION%20AL%20REVERSING%20CON%20IDA%20PRO%20DESDE%20CERO/27-INTRODUCCION%20AL%20REVERSING%20CON%20IDA%20PRO%20DESDE%20CERO%20PARTE%2027.7z**](http://ricardonarvaja.info/WEB/INTRODUCCION%20AL%20REVERSING%20CON%20IDA%20PRO%20DESDE%20CERO/27-INTRODUCCION%20AL%20REVERSING%20CON%20IDA%20PRO%20DESDE%20CERO%20PARTE%2027.7z)
